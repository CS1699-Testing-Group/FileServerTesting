import java.util.*;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.*;
import java.security.spec.KeySpec;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.Hex;

public class Security4_6Test {

	public static ArrayList<String>keys;
	
	public static void main(String[] args) throws Exception {
		
	//Part 1: Group server side.
	//The group server needs a way to remember all keys generated to give to group members (Hashtable)
	//This hashtable is parsed by groupname in order to give a user all the keys he needs based on groupname
		String groupname = "Johnsgroup";
		String s1;
		Hashtable<String,ArrayList<String>> groupKeyTable = new Hashtable<String,ArrayList<String>>(); //key storage on GS side
		Security.addProvider(new BouncyCastleProvider());
		
	// SOMEONE CREATED A GROUP, GENERATE A KEY PAIR
	//On group creation, a key pair must be generated by the group server and put into its hashtable
		System.out.println("GENERATING KEY");
		Key key = GenerateSymmetricKey(128);
		byte[] IV = new byte[16];
		Random random = new SecureRandom();
		random.nextBytes(IV);
		byte[] key_bytes = key.getEncoded();
		System.out.print("Actual key: ");
		if(groupKeyTable.contains(groupname)){
			s1 = String.valueOf(groupKeyTable.get(groupname).size())+"_"+groupname+"_"+Hex.toHexString(key_bytes)+"_"+Hex.toHexString(IV);
		}else{
			s1 = "0_"+groupname+"_"+Hex.toHexString(key_bytes)+"_"+Hex.toHexString(IV);
		}
		System.out.println(s1);
		System.out.println("END GENERATING KEY");
		// KEY GENERATION COMPLETED
		
		
	//ADD KEY TO HASHTABLE
		System.out.println("ADDING KEY TO GROUP SERVER HASHTABLE");
		if(groupKeyTable.containsKey(groupname)){
			ArrayList<String> currentList = groupKeyTable.get(groupname);
			currentList.add(s1);
		}else{
			ArrayList<String> newList = new ArrayList<String>();
			newList.add(s1);
		}
	//KEY ADDED TO HASHTABLE 
		
	//PACKAGE ALL KEYS FOR USER
	//When a user recieves a token, they also recieve an envelope with ALL keys they have access to
		
		//TODO XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		//FOR EACH GROUP IN USER.GROUPS
		//SCAN THE HASHTABLE FOR ALL KEYS FOR THAT GROUP
		//PUT THAT KEY IN THE ARRAYLIST KEYS
		keys = new ArrayList<String>();
		keys.add(s1);
		//TODO XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	
	//
		
	System.out.println("");
	System.out.println("I am a user");
	//MAINUSERINTERFACE SIDE
		//ADD KEY TO LOCAL FILE AT THE NEXT LINE UPON TOKEN RECEPTION
		//When a user recieves a token, he/she also recieves an envelope full of all the keys 
		System.out.println("Adding keys to groupkeys.txt from the group server envelope");
		BufferedWriter out = new BufferedWriter(new FileWriter("GroupKeys.txt",true));
		
		//KEYS IS THE ARRAYLIST FOUND IN THE ENVELOPE
		//keys = (ArrayList<String>)ENVELOPE.OBJECT(0);
		for(int i = 0; i < keys.size();i++){
			out.write(keys.get(i)); //write all keys to the file line by line 
			out.newLine();
		}
		out.close();
		
		//ENCRYPTION ON UPLOAD - USE KEY NUMBER AND GROUPNAME BASED ON MOST RECENT KEY
		System.out.println("I want to upload this file, it needs to be encrypted.");
		System.out.println("READING MOST RECENT KEY I NEED FROM GROUPKEYS.TXT ON THE USER SIDE");
		String toUpload_groupname = "Johnsgroup";//FILE FLAGGED FOR THIS GROUP
		String toUpload_correctKey = "";
		String toUpload_correctIV = "";
		boolean toUpload_found_correctKey = false;
		
		BufferedReader in = new BufferedReader(new FileReader("GroupKeys.txt"));
		String line;
		int maxKeyNumber = -1;
		
		while((line = in.readLine())!=null){ //read file line by line and split by underscore
			String lineArray[] = line.split("_");
			int line_keyNumber = Integer.parseInt(lineArray[0]);
			String line_groupname = lineArray[1];
			
			if(line_groupname.equals(toUpload_groupname) && line_keyNumber > maxKeyNumber){
				toUpload_found_correctKey = true;
				toUpload_correctKey = lineArray[2];
				toUpload_correctIV = lineArray[3];
			}
		}
		if(toUpload_found_correctKey == true){//YAY WE HAVE THE KEY
			//System.out.println("Actual key-------");
			//System.out.println(toUpload_correctKey);
		}else{
			System.out.println("You don't have the key to decrypt this file, please obtain a new token");
			System.exit(0);//CAN'T UPLOAD A FILE WITHOUT ANY KEYS
		}
		
		//NEED TO GENERATE THE AES KEY FROM THE STRING FOUND IN GROUPKEYS.BIN
		byte[] aesBytes = Hex.decode(toUpload_correctKey); //generate public key bytes using string value of key
		byte[] IVBytes = Hex.decode(toUpload_correctIV);
		SecretKeySpec key_from_file = new SecretKeySpec(aesBytes, "AES");    
		
		//ENCRYPT CONTENTS OF FILE 		
		Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding", "BC");
		System.out.println("Starting encryption..");
		cipher.init(Cipher.ENCRYPT_MODE, key_from_file, new IvParameterSpec(IVBytes)); //encrypt using key
		
		File newfile = new File("toEncrypt.txt");
		FileInputStream fis = new FileInputStream(newfile);
		
		File file = new File("Encrypted.txt");
		file.createNewFile();
		FileOutputStream fos = new FileOutputStream(file);
		
		CBCEncrypt(cipher,fis,fos);
		
		System.out.println("Finished encryption.");
		//END OF ENCRYPTING THE FILE, IT IS READY FOR UPLOADING (ENCRYPTED.TXT)
		
		System.out.println("");
		//DECRYPTION ON DOWNLOAD - WE KNOW KEY NUMBER AND GROUPNAME GIVEN BY FILESERVER FLAGGING
		//1. NEED TO READ THE CORRECT KEY FROM THE FILE
		System.out.println("I just downloaded an encrypted file.");
		System.out.println("READING THE KEY I NEED FROM THE FILE ON THE USER SIDE");
		String fileserver_groupname = "Johnsgroup";//GROUP NAME
		int fileserver_keynumber = 0;//DECRYPTION KEY NUMBER
		String fileserver_correctKey = "";
		String fileserver_correctIV = "";
		boolean fileserver_found_correctKey = false;
		
		BufferedReader READin = new BufferedReader(new FileReader("GroupKeys.txt"));
		String READline;
		while((READline = READin.readLine())!=null){ //read file line by line and split by underscore
			String lineArray[] = READline.split("_");
			int line_keyNumber = Integer.parseInt(lineArray[0]);
			String line_groupname = lineArray[1];
			
			if(line_groupname.equals(fileserver_groupname) && line_keyNumber == fileserver_keynumber){ //IF KEY MATCHES PARAMETERS
				fileserver_found_correctKey = true;
				fileserver_correctKey = lineArray[2];
				fileserver_correctIV = lineArray[3];
			}
		}
		if(fileserver_found_correctKey == true){
			System.out.print("Found the needed key: ");
			System.out.println(fileserver_correctKey); //WE CAN DECRYPT
		}else{
			System.out.println("You don't have the key to decrypt this file, please obtain a new token");//ERROR OUT
			System.exit(0);
			
		}
		
		//NEED TO GENERATE THE AES KEY FROM THE STRING IN THE FILE
		byte[] DECRYPTaesBytes = Hex.decode(fileserver_correctKey); //generate public key bytes using string value of key
		byte[] DECRYPTIVBytes = Hex.decode(fileserver_correctIV);
		SecretKeySpec DECRYPTkey_from_file = new SecretKeySpec(DECRYPTaesBytes, "AES");       
		
		//DECRYPT FILE CONTENTS WITH key_from_file
		Cipher DECRYPTcipher = Cipher.getInstance("AES/CBC/PKCS7Padding", "BC");
		System.out.println("Starting decryption..");
		DECRYPTcipher.init(Cipher.DECRYPT_MODE, DECRYPTkey_from_file, new IvParameterSpec(DECRYPTIVBytes)); //encrypt using key
		
		File toDecrypt = new File("Encrypted.txt");
		FileInputStream toDecryptfis = new FileInputStream(toDecrypt);
		
		File Decryptednewfile = new File("Decrypted.txt");
		Decryptednewfile.createNewFile();
		FileOutputStream Decryptedfos = new FileOutputStream(Decryptednewfile);
		
		CBCDecrypt(DECRYPTcipher,toDecryptfis,Decryptedfos);
		
		System.out.print("Finished Decryption");
		//DECRYPTED FILE IS DECRYPTED.TXT
			 
			
	}

	public static SecretKey GenerateSymmetricKey(int keySizeInBits)throws Exception {
		KeyGenerator keyGenerator = KeyGenerator.getInstance("AES", "BC");
		keyGenerator.init(keySizeInBits);
		SecretKey secretkey = keyGenerator.generateKey();
		return secretkey;
	}
	
	public static void CBCEncrypt(Cipher encryptCipher,FileInputStream fis, FileOutputStream fos)throws IOException,ShortBufferException,IllegalBlockSizeException,BadPaddingException{
       byte[] buffer = new byte[16];
       int noBytes = 0;
       byte[] cipherBlock =new byte[encryptCipher.getOutputSize(buffer.length)];
       int cipherBytes;
       while((noBytes = fis.read(buffer))!=-1){
           cipherBytes =encryptCipher.update(buffer, 0, noBytes, cipherBlock);
           fos.write(cipherBlock, 0, cipherBytes);
       }
       cipherBytes = encryptCipher.doFinal(cipherBlock,0);
       fos.write(cipherBlock,0,cipherBytes);
 
       fos.close();
       fis.close();
    }
	
	public static void CBCDecrypt(Cipher DecryptCipher,FileInputStream in, FileOutputStream out)throws ShortBufferException,IllegalBlockSizeException,BadPaddingException,DataLengthException,IllegalStateException,InvalidCipherTextException,IOException{
		byte[] buffer = new byte[16];
	    int noBytes = 0;
	    byte[] cipherBlock = new byte[DecryptCipher.getOutputSize(buffer.length)];
	    int cipherBytes;
	    
	    while((noBytes = in.read(buffer))!=-1){
	           cipherBytes = DecryptCipher.update(buffer, 0, noBytes, cipherBlock);
	           out.write(cipherBlock, 0, cipherBytes);
	    }
	    cipherBytes = DecryptCipher.doFinal(cipherBlock,0);
	    out.write(cipherBlock,0,cipherBytes);
	 
	    out.close();
	    in.close();
	}
}
